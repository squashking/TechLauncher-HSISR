import os
from io import BytesIO
from typing import Callable, TypeAlias

import numpy as np
import spectral
from PIL.ImageQt import QPixmap
from matplotlib import pyplot as plt
import spectral.image
from spectral.io import envi
from spectral.io.bilfile import BilFile
from spectral.io.bipfile import BipFile
from spectral.io.bsqfile import BsqFile
from spectral.io.envi import SpectralLibrary


HSI: TypeAlias = SpectralLibrary | BilFile | BipFile | BsqFile


def read_psi_header(file_path : str) -> dict:
    data_dict = {}
    wavelengths = []

    # Open the text file
    with open(file_path, "r") as file:
        # Parse the lines and store values in the dictionary
        for line in file:
            parts = line.strip().split(" ")
            if "WAVELENGTHS" in parts:
                reading_wavelengths = True
                continue
            elif "WAVELENGTHS_END" in parts:
                reading_wavelengths = False
                data_dict["WAVELENGTHS"] = wavelengths
                continue

            if len(parts) == 2:
                key, value = parts
                data_dict[key] = value
            elif reading_wavelengths:
                wavelengths.append(float(parts[0]))

    return data_dict


def create_envi_header(filename : str, meta_dict : dict):
    # Create an ENVI header file for PSI images
    with open(filename, "w") as file:
        file.write("ENVI\n")
        file.write("description = {Generated by Python}\n")
        file.write("bands = {}\n".format(meta_dict["NBANDS"]))
        file.write("byte order = 0\n")
        file.write("data type = {}\n".format(meta_dict["NBITS"]))
        file.write("file type = ENVI Standard\n")
        file.write("header offset = 0\n")
        file.write("interleave = {}\n".format(meta_dict["LAYOUT"].lower()))
        file.write("lines = {}\n".format(meta_dict["NROWS"]))
        file.write("samples = {}\n".format(meta_dict["NCOLS"]))
        file.write("wavelength units = nm\n")
        file.write("wavelength = {")
        file.write(",".join(map(str, meta_dict["WAVELENGTHS"])))
        file.write("}\n")


def create_header_by_template(template_file: str, save_path: str, n_lines: int, n_samples: int, data_type: int):
    with open(template_file, "r") as file:
        lines = file.readlines()
    with open(save_path, "w") as file:
        for line in lines:
            if line.startswith("lines ="):
                parts = line.strip().split("=")
                key, value = parts[0], int(parts[1].strip())
                new_value = n_lines
                file.write(f"{key} = {new_value}\n")
            elif line.startswith("samples ="):
                parts = line.strip().split("=")
                key, value = parts[0], int(parts[1].strip())
                new_value = n_samples
                file.write(f"{key} = {new_value}\n")
            elif line.startswith("data type ="):
                parts = line.strip().split("=")
                key, value = parts[0], int(parts[1].strip())
                new_value = data_type
                file.write(f"{key} = {new_value}\n")
            else:
                file.write(line)


def load_hsi(bil_path : str, header_path : str) -> HSI:
    # Check if it's PSI image format
    with open(header_path, "r") as file:
        first_line = file.readline().strip()
    if first_line.startswith("BYTEORDER"):  # PSI format
        # Rename
        base, ext = os.path.splitext(header_path)
        new_header_path = f"{base}_BYTEORDER{ext}"
        os.rename(header_path, new_header_path)
        # Read data and create an ENVI one
        meta_dict = read_psi_header(new_header_path)
        create_envi_header(header_path, meta_dict)

    hsi = envi.open(header_path, bil_path)
    return hsi


def find_rgb_bands(list_wavelength: list[float]) -> tuple[int, int, int] | None:
    # This function assumes listWavelength is in ascending order
    r_wavelength = 682.5  # (625+740)/2
    g_wavelength = 532.5  # (495+570)/2
    b_wavelength = 472.5  # (450+495)/2
    list_len = len(list_wavelength)
    if list_len < 3:
        print("Error: not a hyperspectral file")
        return None
    if list_wavelength[0] > b_wavelength or list_wavelength[-1] < r_wavelength:  # if not fully include RGB bands
        return round(5 * list_len / 6), round(list_len / 2), round(list_len / 6)  # considering edge effect, not use (len, len/2, 1)

    r_found = g_found = b_found = False
    r_pre_difference = g_pre_difference = b_pre_difference = float("inf")  # previously calculated difference
    r_index = g_index = b_index = 0

    for i, value in enumerate(list_wavelength):
        if not r_found:
            difference = abs(value - r_wavelength)
            if difference < r_pre_difference:
                r_pre_difference = difference
            else:  # when the distance starts to grow bigger, the index is found, and it should be the previous i
                r_index = i - 1
                r_found = True

        if not g_found:
            difference = abs(value - g_wavelength)
            if difference < g_pre_difference:
                g_pre_difference = difference
            else:
                g_index = i - 1
                g_found = True

        if not b_found:
            difference = abs(value - b_wavelength)
            if difference < b_pre_difference:
                b_pre_difference = difference
            else:
                b_index = i - 1
                b_found = True

    return r_index, g_index, b_index


def _plot_qpixmap_in_memory(plot_function : Callable[[BytesIO], None]) -> QPixmap:
    buf = BytesIO()
    plot_function(buf)
    buf.seek(0)
    pixmap = QPixmap()
    pixmap.loadFromData(buf.getvalue())
    return pixmap


def _normalise_all(arr : np.ndarray[tuple[int, ...], np.dtype[np.float64]]) \
        -> np.ndarray[tuple[int, ...], np.dtype[np.float64]]:
    min_val = np.min(arr)
    max_val = np.max(arr)

    # Ensure the denominator is not zero
    range_val = max_val - min_val
    if range_val == 0:
        range_val = 1e-10

    return (arr - min_val) / range_val


def convert_hsi_to_rgb_qpixmap(hsi : HSI) -> QPixmap:
    # metadata["wavelength"] is read as string; for CSIRO image, can use self.hsi.bands.centers
    tuple_rgb_bands = find_rgb_bands([float(i) for i in hsi.metadata["wavelength"]])

    rgb_image = spectral.get_rgb(hsi, tuple_rgb_bands)  # (100, 54, 31)
    rgb_image = (rgb_image * 255).astype(np.uint8)
    rgb_image = rgb_image.copy()  # Spy don't load it to memory automatically, so must be copied

    return _plot_qpixmap_in_memory(lambda buf: plt.imsave(buf, rgb_image))


def convert_hsi_to_ndvi_qpixmap(hsi : HSI) -> QPixmap:
    """
    Calculate NDVI from hyperspectral image data.

    Parameters:
    - hsi: Hyperspectral image object loaded with spectral library.

    Returns:
    - ndvi_pixmap: Calculated NDVI as a QPixmap.
    """
    # Assume Near Infrared (NIR) band is around 800 nm and Red band is around 670 nm
    nir_band_index = find_rgb_bands([float(i) for i in hsi.metadata["wavelength"]])[0]
    red_band_index = find_rgb_bands([float(i) for i in hsi.metadata["wavelength"]])[1]

    nir_band = hsi.read_band(nir_band_index)
    red_band = hsi.read_band(red_band_index)

    ndvi_array = (nir_band - red_band) / (nir_band + red_band + 1e-10)  # Add small value to avoid division by zero
    ndvi_image = (ndvi_array - np.min(ndvi_array)) / (np.max(ndvi_array) - np.min(ndvi_array))  # Normalize to 0-1

    return _plot_qpixmap_in_memory(lambda buf : plt.imsave(buf, ndvi_image, cmap="RdYlGn"))


def convert_hsi_to_evi_qpixmap(hsi : HSI) -> QPixmap:
    """
    Calculate EVI from hyperspectral image data.

    Parameters:
    - hsi: Hyperspectral image object loaded with spectral library.

    Returns:
    - evi_array: Calculated EVI as a QPixmap.
    """
    nir_band_index = find_rgb_bands([float(i) for i in hsi.metadata["wavelength"]])[0]
    red_band_index = find_rgb_bands([float(i) for i in hsi.metadata["wavelength"]])[1]
    blue_band_index = find_rgb_bands([float(i) for i in hsi.metadata["wavelength"]])[2]

    nir_band = hsi.read_band(nir_band_index)
    red_band = hsi.read_band(red_band_index)
    blue_band = hsi.read_band(blue_band_index)

    # Calculate EVI
    numerator = nir_band - red_band
    denominator = (nir_band + 6 * red_band - 7.5 * blue_band + 1)

    # Ignore divide by zero and invalid warnings
    with np.errstate(divide="ignore", invalid="ignore"):
        evi_array = numerator / denominator
        evi_array[np.isnan(evi_array)] = 0  # Set NaNs to 0

    # Replace NaNs and Infs with finite numbers (0)
    evi_array = np.nan_to_num(evi_array, nan=0.0, posinf=0.0, neginf=0.0)

    # Normalise EVI for visualization
    evi_image = _normalise_all(evi_array)

    return _plot_qpixmap_in_memory(lambda buf : plt.imsave(buf, evi_image, cmap="RdYlGn"))


def convert_hsi_to_mcari_qpixmap(hsi : HSI) -> QPixmap:
    """
    Calculate MCARI from hyperspectral image data.

    Parameters:
    - hsi: Hyperspectral image object loaded with spectral library.

    Returns:
    - mcari_array: Calculated MCARI as a QPixmap.
    """
    # Find the band indices corresponding to 700 nm, 670 nm, and 550 nm
    band_700_index = find_rgb_bands([float(i) for i in hsi.metadata["wavelength"]])[0]  # Assuming 700 nm is near NIR
    band_670_index = find_rgb_bands([float(i) for i in hsi.metadata["wavelength"]])[1]  # Assuming 670 nm is red
    band_550_index = find_rgb_bands([float(i) for i in hsi.metadata["wavelength"]])[1] - 1  # Assuming 550 nm is green

    band_700 = hsi.read_band(band_700_index)
    band_670 = hsi.read_band(band_670_index)
    band_550 = hsi.read_band(band_550_index)

    # Calculate MCARI
    with np.errstate(divide="ignore", invalid="ignore"):
        mcari_array = (band_700 - band_670) - 0.2 * (band_700 - band_550) * (band_700 / (band_670 + 1e-10))  # Add small constant to avoid divide by zero
        mcari_array[np.isnan(mcari_array)] = 0  # Set NaNs to 0

    # Replace NaNs and Infs with finite numbers (0)
    mcari_array = np.nan_to_num(mcari_array, nan=0.0, posinf=0.0, neginf=0.0)

    # Normalise MCARI for visualization
    mcari_image = _normalise_all(mcari_array)

    return _plot_qpixmap_in_memory(lambda buf : plt.imsave(buf, mcari_image, cmap="viridis"))


def convert_hsi_to_mtvi_qpixmap(hsi : HSI) -> QPixmap:
    """
    Calculate MTVI from hyperspectral image data.

    Parameters:
    - hsi: Hyperspectral image object loaded with spectral library.

    Returns:
    - mtvi_array: Calculated MTVI as a QPixmap.
    """
    # Find the band indices corresponding to 800 nm, 670 nm, and 550 nm
    band_800_index = find_rgb_bands([float(i) for i in hsi.metadata["wavelength"]])[0]  # Assuming 800 nm is NIR
    band_670_index = find_rgb_bands([float(i) for i in hsi.metadata["wavelength"]])[1]  # Assuming 670 nm is red
    band_550_index = find_rgb_bands([float(i) for i in hsi.metadata["wavelength"]])[1] - 1  # Assuming 550 nm is green

    band_800 = hsi.read_band(band_800_index)
    band_670 = hsi.read_band(band_670_index)
    band_550 = hsi.read_band(band_550_index)

    # Calculate MTVI
    mtvi_array = 1.2 * ((1.2 * (band_800 - band_550)) - (2.5 * (band_670 - band_550)))

    # Replace NaNs and Infs with finite numbers (0)
    mtvi_array = np.nan_to_num(mtvi_array, nan=0.0, posinf=0.0, neginf=0.0)

    # Normalise MTVI for visualization
    mtvi_image = _normalise_all(mtvi_array)

    return _plot_qpixmap_in_memory(lambda buf : plt.imsave(buf, mtvi_image, cmap="viridis"))


def convert_hsi_to_osavi_qpixmap(hsi : HSI) -> QPixmap:
    """
    Calculate OSAVI from hyperspectral image data.

    Parameters:
    - hsi: Hyperspectral image object loaded with spectral library.

    Returns:
    - osavi_array: Calculated OSAVI as a QPixmap.
    """
    nir_band_index = find_rgb_bands([float(i) for i in hsi.metadata["wavelength"]])[0]  # NIR around 800 nm
    red_band_index = find_rgb_bands([float(i) for i in hsi.metadata["wavelength"]])[1]  # Red around 670 nm

    nir_band = hsi.read_band(nir_band_index)
    red_band = hsi.read_band(red_band_index)

    osavi_array = (nir_band - red_band) / (nir_band + red_band + 0.16)

    osavi_image = (osavi_array - np.min(osavi_array)) / (np.max(osavi_array) - np.min(osavi_array))

    return _plot_qpixmap_in_memory(lambda buf : plt.imsave(buf, osavi_image, cmap="RdYlGn"))


def convert_hsi_to_pri_qpixmap(hsi : HSI) -> QPixmap:
    """
    Calculate PRI from hyperspectral image data.

    Parameters:
    - hsi: Hyperspectral image object loaded with spectral library.

    Returns:
    - pri_array: Calculated PRI as a QPixmap.
    """
    # Find the band indices corresponding to 531 nm and 570 nm
    band_531_index = find_rgb_bands([float(i) for i in hsi.metadata["wavelength"]])[1] - 2  # Assuming 531 nm is near green
    band_570_index = find_rgb_bands([float(i) for i in hsi.metadata["wavelength"]])[1] - 1  # Assuming 570 nm is green

    band_531 = hsi.read_band(band_531_index)
    band_570 = hsi.read_band(band_570_index)

    # Calculate PRI
    with np.errstate(divide="ignore", invalid="ignore"):
        pri_array = (band_531 - band_570) / (band_531 + band_570 + 1e-10)  # Add small constant to avoid divide by zero
        pri_array[np.isnan(pri_array)] = 0  # Set NaNs to 0

    # Replace NaNs and Infs with finite numbers (0)
    pri_array = np.nan_to_num(pri_array, nan=0.0, posinf=0.0, neginf=0.0)

    # Normalise PRI for visualization
    pri_image = _normalise_all(pri_array)

    return _plot_qpixmap_in_memory(lambda buf : plt.imsave(buf, pri_image, cmap="Spectral"))


def convert_hsi_to_hypercube_qpixmap(hsi : HSI) -> QPixmap:
    data = hsi
    assert len(data.shape) == 3

    bands = list(find_rgb_bands([float(i) for i in data.metadata["wavelength"]]))
    r_band, g_band, b_band = bands[0], bands[1], bands[2]
    r_image = data[:, :, r_band]
    g_image = data[:, :, g_band]
    b_image = data[:, :, b_band]
    r_image[r_image < 0] = 0
    g_image[g_image < 0] = 0
    b_image[b_image < 0] = 0
    r_image_normalized = r_image / np.max(r_image)
    g_image_normalized = g_image / np.max(g_image)
    b_image_normalized = b_image / np.max(b_image)

    rgb_data = np.dstack((r_image_normalized, g_image_normalized, b_image_normalized))
    fig = plt.figure(figsize=(10, 10))
    ax = fig.add_subplot(111, projection='3d')

    x_dim, y_dim, z_dim = data.shape
    X, Y = np.meshgrid(np.arange(y_dim), np.arange(x_dim))

    ax.plot_surface(X, Y, np.full((x_dim, y_dim), z_dim),
                    facecolors=rgb_data, rstride=1, cstride=1, shade=True)

    _normalise_data_func = lambda _d: (_d - np.min(_d)) / (np.max(_d) - np.min(_d))
    side1 = _normalise_data_func(data[:, y_dim - 100, :])
    side2 = _normalise_data_func(data[x_dim - 100, :, :])

    X_side1, Z_side1 = np.meshgrid(np.arange(x_dim), np.arange(z_dim))
    Y_side2, Z_side2 = np.meshgrid(np.arange(y_dim), np.arange(z_dim))

    side1 = np.squeeze(side1).T
    side2 = np.squeeze(side2).T

    ax.plot_surface(np.full_like(X_side1, y_dim), X_side1, Z_side1,
                    facecolors=plt.cm.viridis(side1), rstride=1, cstride=1, shade=True)
    ax.plot_surface(Y_side2, np.full_like(Y_side2, x_dim), Z_side2,
                    facecolors=plt.cm.viridis(side2), rstride=1, cstride=1, shade=True)

    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Wavelength')
    ax.set_xlim(0, y_dim)
    ax.set_ylim(0, x_dim)
    ax.set_zlim(0, z_dim)

    ax.view_init(elev=30, azim=45)
    plt.title('Hypercube Visualization')

    return _plot_qpixmap_in_memory(lambda buf: plt.savefig(buf, dpi=300, bbox_inches="tight"))


def plot_spectrum(hsi_data : np.ndarray, metadata : dict, x : int, y : int):
    """
    Plot spectrum for a given pixel (x, y) of the HSI.

    Parameters:
    -----------
    - hsi_data: Data of the HSI (height, width, bands)
    - metadata: Metadata of the original HSI
    - x, y: Given pixel coordinates
    """
    # 提取像素点在所有波段上的光谱数据
    spectrum = hsi_data[y, x, :]  # 注意y是行，x是列
    # 如果 spectrum 是一个多维数组，需要将其展平成一维
    spectrum = spectrum.flatten()
    # 绘制光谱图
    plt.figure(figsize=(10, 6))
    wavelengths = [float(w) for w in metadata['wavelength']]
    if wavelengths is not None:
        plt.plot(wavelengths, spectrum)
        plt.xlabel("Wavelength (nm)")
    else:
        plt.plot(range(spectrum.shape[0]), spectrum)
        plt.xlabel("Band Index")

    plt.ylabel("Reflectance")
    plt.title(f"Spectrum at Pixel ({y}, {x})")
    plt.grid(True)
    plt.show()


def calibrate(dark_hsi : HSI, ref_hsi : HSI, input_hsi : HSI, output_filename : str = None) -> HSI:
    """
    Calibrate a hyperspectral image using dark and reference images.

    Parameters:
    -----------
    dark_hsi : spectral.SpyFile
        Dark reference image
    ref_hsi : spectral.SpyFile
        White reference image
    input_hsi : spectral.SpyFile
        Input image to calibrate
    output_filename : str, optional
        Output file name without extension (default: None)

    Returns:
    --------
    spectral.SpyFile
        Calibrated image
    """
    assert dark_hsi.shape == ref_hsi.shape

    with np.errstate(divide="ignore", invalid="ignore"):
    # Calculate subtracting and dividing factors
        subt = np.repeat(
            np.average(dark_hsi[:, :, :], axis=0, keepdims=True),
            input_hsi.shape[0], axis=0
        )

        divisor = np.repeat(
            np.average(ref_hsi[:, :, :] - dark_hsi[:, :, :], axis=0, keepdims=True),
            input_hsi.shape[0], axis=0
        )

        # Apply calibration formula and clip to valid range
        result = np.clip(
            ((input_hsi[:, :, :] - subt) / divisor) * 255,
            0, 255
        )

    # Set output file paths
    if output_filename is None:
        output_hdr = "calibration.hdr"
        output_bil = "calibration.bil"
    else:
        # Make sure the directory exists
        output_dir = os.path.dirname(output_filename)
        if output_dir and not os.path.exists(output_dir):
            os.makedirs(output_dir)

        output_hdr = output_filename + ".hdr"
        output_bil = output_filename + ".bil"

    # Save calibrated image
    envi.save_image(output_hdr, result, dtype=np.uint8,
                    interleave="bil", ext="bil", force=True, metadata=dark_hsi.metadata)

    # Open and return the calibrated image
    output_hsi = envi.open(output_hdr, output_bil)

    return output_hsi

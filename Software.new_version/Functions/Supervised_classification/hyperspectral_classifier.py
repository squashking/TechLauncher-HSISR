import spectral as spy
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
import spectral.io.envi as envi
import os

class HyperspectralClassifier:
    def __init__(self):
        self.hsi = None
        self.gt = None
    
    def load_image(self, image_path, header_path):
        """
        Loads the hyperspectral image and checks if it is in PSI format. 
        Converts it to ENVI format and loads the image using the header file.
        """
        # Check if it's PSI image format
        with open(header_path, "r") as file:
            first_line = file.readline().strip()
        
        if first_line.startswith("BYTEORDER"):  # PSI format
            dictMeta = self.read_PSI_header(header_path)
            self.create_envi_header(header_path, dictMeta)

        self.hsi = envi.open(header_path, image_path)
    
    def read_PSI_header(self, file_path):
        """
        Reads the PSI header and converts it to a dictionary format for easier processing.
        """
        data_dict = {}
        with open(file_path, "r") as file:
            lines = file.readlines()

        wavelengths = []
        reading_wavelengths = False
        for line in lines:
            parts = line.strip().split(" ")
            if "WAVELENGTHS" in parts:
                reading_wavelengths = True
                continue
            elif "WAVELENGTHS_END" in parts:
                reading_wavelengths = False
                data_dict["WAVELENGTHS"] = wavelengths
                continue

            if len(parts) == 2:
                key, value = parts
                data_dict[key] = value
            elif reading_wavelengths:
                wavelengths.append(float(parts[0]))

        return data_dict

    def create_envi_header(self, filename, dictMeta):
        """
        Creates an ENVI header file from the PSI metadata.
        """
        with open(filename, 'w') as file:
            file.write("ENVI\n")
            file.write("description = {Generated by Python}\n")
            file.write("bands = {}\n".format(dictMeta['NBANDS']))
            file.write("byte order = 0\n")
            file.write("data type = {}\n".format(dictMeta['NBITS']))
            file.write("file type = ENVI Standard\n")
            file.write("header offset = 0\n")
            file.write("interleave = {}\n".format(dictMeta['LAYOUT'].lower()))
            file.write("lines = {}\n".format(dictMeta['NROWS']))
            file.write("samples = {}\n".format(dictMeta['NCOLS']))
            file.write("wavelength units = nm\n")
            file.write("wavelength = {")
            file.write(','.join(map(str, dictMeta['WAVELENGTHS'])))
            file.write("}\n")

    def classify(self, mask_path, classifier_type='Gaussian'):
        """
        Performs the classification using the selected classifier (Gaussian, Mahalanobis, or Perceptron)
        and saves the results.
        """
        # Load the hyperspectral image data
        img = self.hsi.load()

        # Load the ground truth image (mask)
        gt_img = Image.open(mask_path)
        self.gt = np.array(gt_img)

        # Create training classes based on the ground truth
        classes = spy.create_training_classes(img, self.gt)

        # Select classifier based on input
        if classifier_type == 'Gaussian':
            classifier = spy.GaussianClassifier(classes)
        elif classifier_type == 'Mahalanobis':
            # Temporarily assign np.float to np.float64 to avoid deprecation errors
            np.float = np.float64
            classifier = spy.MahalanobisDistanceClassifier(classes)
        elif classifier_type == 'Perceptron':
            # Map ground truth labels to consecutive integers starting from 0
            unique_labels = np.unique(self.gt)
            label_mapping = {label: idx for idx, label in enumerate(unique_labels)}
            ground_truth_mapped = np.copy(self.gt)
            for original_label, mapped_label in label_mapping.items():
                ground_truth_mapped[self.gt == original_label] = mapped_label

            # Create training classes based on the mapped ground truth
            training_classes = spy.create_training_classes(img, ground_truth_mapped)

            # Determine the number of input neurons (equal to the number of spectral bands)
            input_neurons = img.shape[-1]
            # Number of output neurons (equal to the number of unique classes)
            num_classes = len(training_classes)

            # Initialize Perceptron classifier with appropriate layers
            layers = [input_neurons, 100, 50, num_classes]
            classifier = spy.PerceptronClassifier(layers=layers)

            # Train the Perceptron model
            classifier.train(training_classes, max_iterations=10)

        else:
            raise ValueError(f"Unknown classifier type: {classifier_type}")

        # Perform classification on the entire image
        clmap = classifier.classify_image(img)

        # Restore np.float to its original type (just for completeness, though it's not strictly necessary)
        if classifier_type == 'Mahalanobis':
            np.float = float

        # Create result folder if it doesn't exist
        result_folder = "result"
        if not os.path.exists(result_folder):
            os.makedirs(result_folder)

        # Only show classification results where there is ground truth
        gtresults = clmap * (self.gt != 0)
        spy.imshow(classes=gtresults)
        plt.savefig(os.path.join(result_folder, f'gtresults_{classifier_type}.png'))
        plt.close()  # Close the plot to avoid showing in GUI return

        return os.path.join(result_folder, f'gtresults_{classifier_type}.png')

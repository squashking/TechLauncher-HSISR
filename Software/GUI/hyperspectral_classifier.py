# hyperspectral_classifier.py

import spectral as spy
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
import spectral.io.envi as envi
import os

class HyperspectralClassifier:
    def __init__(self):
        self.hsi = None
        self.gt = None
    
    def load_image(self, image_path, header_path):
        """
        Loads the hyperspectral image and checks if it is in PSI format. 
        Converts it to ENVI format and loads the image using the header file.
        """
        # Check if it's PSI image format
        with open(header_path, "r") as file:
            first_line = file.readline().strip()
        
        if first_line.startswith("BYTEORDER"):  # PSI format
            dictMeta = self.read_PSI_header(header_path)
            self.create_envi_header(header_path, dictMeta)

        self.hsi = envi.open(header_path, image_path)
    
    def read_PSI_header(self, file_path):
        """
        Reads the PSI header and converts it to a dictionary format for easier processing.
        """
        data_dict = {}
        with open(file_path, "r") as file:
            lines = file.readlines()

        wavelengths = []
        reading_wavelengths = False
        for line in lines:
            parts = line.strip().split(" ")
            if "WAVELENGTHS" in parts:
                reading_wavelengths = True
                continue
            elif "WAVELENGTHS_END" in parts:
                reading_wavelengths = False
                data_dict["WAVELENGTHS"] = wavelengths
                continue

            if len(parts) == 2:
                key, value = parts
                data_dict[key] = value
            elif reading_wavelengths:
                wavelengths.append(float(parts[0]))

        return data_dict

    def create_envi_header(self, filename, dictMeta):
        """
        Creates an ENVI header file from the PSI metadata.
        """
        with open(filename, 'w') as file:
            file.write("ENVI\n")
            file.write("description = {Generated by Python}\n")
            file.write("bands = {}\n".format(dictMeta['NBANDS']))
            file.write("byte order = 0\n")
            file.write("data type = {}\n".format(dictMeta['NBITS']))
            file.write("file type = ENVI Standard\n")
            file.write("header offset = 0\n")
            file.write("interleave = {}\n".format(dictMeta['LAYOUT'].lower()))
            file.write("lines = {}\n".format(dictMeta['NROWS']))
            file.write("samples = {}\n".format(dictMeta['NCOLS']))
            file.write("wavelength units = nm\n")
            file.write("wavelength = {")
            file.write(','.join(map(str, dictMeta['WAVELENGTHS'])))
            file.write("}\n")

    def classify(self, mask_path):
        """
        Performs the classification using the GaussianClassifier and saves the results.
        """
        # Load the hyperspectral image data
        img = self.hsi.load()

        # Load the ground truth image (mask)
        gt_img = Image.open(mask_path)
        self.gt = np.array(gt_img)

        # Create training classes based on the ground truth
        classes = spy.create_training_classes(img, self.gt)
        gmlc = spy.GaussianClassifier(classes)

        # Perform classification on the entire image
        clmap = gmlc.classify_image(img)

        # Create result folder if it doesn't exist
        result_folder = "result"
        if not os.path.exists(result_folder):
            os.makedirs(result_folder)

        # Only show classification results where there is ground truth
        gtresults = clmap * (self.gt != 0)
        spy.imshow(classes=gtresults)
        plt.savefig(os.path.join(result_folder, 'gtresults.png'))
        plt.close()  # Close the plot to avoid showing in GUI return

        return os.path.join(result_folder, 'gtresults.png')

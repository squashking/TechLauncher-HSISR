import sys
#from spectral import *
import spectral.io.envi as envi
from spectral import get_rgb
import numpy as np
import matplotlib.pyplot as plt
import os


def find_RGB_bands(listWavelength):
    R_wavelength = 682.5 #(625+740)/2 
    G_wavelength = 532.5  #(495+570)/2 
    B_wavelength = 472.5  #(450+495)/2 
    listlen = len(listWavelength) 
    if listlen < 3:
        print("Error: not a hyperspectral file")
        return
    if listWavelength[0] > B_wavelength or listWavelength[-1] < R_wavelength: # if not fully include RGB bands
        return (round(5*listlen/6), round(listlen/2), round(listlen/6)) # considering edge effect, not use (len, len/2, 1)
    
    rFound = gFound = bFound = False
    rPreDifference = gPreDifference = bPreDifference = float('inf') # previously calculated difference
    rIndex = gIndex = bIndex = 0

    for i, value in enumerate(listWavelength):
        if not rFound:
            difference = abs(value - R_wavelength)
            if difference < rPreDifference:  
                rPreDifference = difference
            else: # when the distance starts to grow bigger, the index is found, and it should be the previous i
                rIndex = i-1
                rFound = True

        if not gFound:
            difference = abs(value - G_wavelength)
            if difference < gPreDifference:
                gPreDifference = difference
            else:
                gIndex = i-1
                gFound = True

        if not bFound:
            difference = abs(value - B_wavelength)
            if difference < bPreDifference:
                bPreDifference = difference
            else:
                bIndex = i-1
                bFound = True 

    return (rIndex, gIndex, bIndex) 


def read_PSI_header(filePath):
    data_dict = {}
    # Open the text file
    with open(filePath, "r") as file:
        lines = file.readlines()
    # Parse the lines and store values in the dictionary
    wavelengths = []
    for line in lines:
        parts = line.strip().split(" ")
        if "WAVELENGTHS" in parts:
            reading_wavelengths = True
            continue
        elif "WAVELENGTHS_END" in parts:
            reading_wavelengths = False
            data_dict["WAVELENGTHS"] = wavelengths
            continue
        
        if len(parts) == 2:
            key, value = parts
            data_dict[key] = value
        elif reading_wavelengths:
            wavelengths.append(float(parts[0]))

    # Display the parsed data
    return data_dict      

#create an ENVI header file for PSI images
def create_envi_header(filename, dictMeta):
    with open(filename, 'w') as file:
        file.write("ENVI\n")
        file.write("description = {Generated by Python}\n")
        file.write("bands = {}\n".format(dictMeta['NBANDS']))
        file.write("byte order = 0\n")
        file.write("data type = {}\n".format(dictMeta['NBITS']))
        file.write("file type = ENVI Standard\n")
        file.write("header offset = 0\n")  
        file.write("interleave = {}\n".format(dictMeta['LAYOUT'].lower()))
        file.write("lines = {}\n".format(dictMeta['NROWS']))
        file.write("samples = {}\n".format(dictMeta['NCOLS']))
        # file.write("sensor type = Unknown\n")
        
        file.write("wavelength units = nm\n")        
        file.write("wavelength = {")
        # for wavelength in dictMeta['WAVELENGTHS']:
            # file.write("{:.2f}, ".format(wavelength))
        file.write(','.join(map(str, dictMeta['WAVELENGTHS'])))
        file.write("}\n")


def change_shape(filePath,save_path,scale_factor):
    with open(filePath, "r") as file:
        lines = file.readlines()
    with open(save_path, "w") as file:
        for line in lines:
            if line.startswith("lines ="):
                parts = line.strip().split("=")
                key, value = parts[0], int(parts[1].strip())
                new_value = value * scale_factor
                file.write(f"{key} = {new_value}\n")
            elif line.startswith("samples ="):
                parts = line.strip().split("=")
                key, value = parts[0], int(parts[1].strip())
                new_value = value * scale_factor
                file.write(f"{key} = {new_value}\n")
            else:
                file.write(line)


def show_rgb(hsi,save_path):
    tuple_rgb_bands = find_RGB_bands([float(i) for i in hsi.metadata['wavelength']])  # metadata['wavelength'] is read as string; for CSIRO image, can use self.hsi.bands.centers
    rgb_image = get_rgb(hsi, tuple_rgb_bands)  # (100, 54, 31)
    rgb_image = (rgb_image*255).astype(np.uint8)
    rgb_image = rgb_image.copy() # Spy don't load it to memory automatically, so must be copied
    print(f"RGB Image Shape: {rgb_image.shape}")
    plt.imshow(rgb_image)
    plt.axis('off')
    plt.show()
    #plt.imsave(save_path, rgb_image)

def load_image(image_path,headerPath):
    # check if it's PSI image format
    with open(headerPath, "r") as file:
        first_line = file.readline().strip()
    print(first_line)
    if first_line.startswith("BYTEORDER"): # PSI format
        dictMeta = read_PSI_header(headerPath)
        headerPath = header_path
        create_envi_header(headerPath, dictMeta)

    hsi = envi.open(headerPath, image_path)
    show_rgb(hsi, None)
    return hsi


def calibration(image_hdr_file, image_bil_file, cal_hdr_file, cal_bil_file, modes, threshold):
    image_hsi = envi.open(image_hdr_file, image_bil_file)
    cal_hsi = envi.open(cal_hdr_file, cal_bil_file)

    assert len(image_hsi.shape) == len(cal_hsi.shape)
    assert image_hsi.shape[1] == cal_hsi.shape[1]
    assert image_hsi.shape[2] == cal_hsi.shape[2]
    assert image_hsi.shape[2] ==len(image_hsi.metadata["wavelength"])
    assert len(image_hsi.metadata["wavelength"]) == len(cal_hsi.metadata["wavelength"])
    for wavelength_0, wavelength_1 in zip(image_hsi.metadata["wavelength"], cal_hsi.metadata["wavelength"]):
        assert abs(float(wavelength_0) - float(wavelength_1)) < 1E-7

    hsi = image_hsi
    bands = range(hsi.nbands)
    data = hsi.read_bands(bands)
    data = data.astype(np.int32)
    wavelengths = hsi.metadata.get('wavelength', [])
    mat_dict = {'ms': data, 'wavelength': wavelengths}
    output = np.zeros(image_hsi.shape, dtype=np.int32)

    for band_id in range(len(image_hsi.metadata["wavelength"])):
        tuple_rgb_bands = find_RGB_bands([float(i) for i in hsi.metadata['wavelength']])
        if "demo" in modes:
            if band_id not in tuple_rgb_bands:
                continue
        if "average" in modes:
            mean_row = np.mean(cal_hsi[:, :, band_id], axis=0).reshape(cal_hsi.shape[1])
            mean_all = np.mean(mean_row)
            gap_arr = mean_row.astype(np.int32)
            gap_arr[gap_arr > threshold] = 0
            for row in range(data.shape[0]):
                output[row, :, band_id] = data[row, :, band_id] + gap_arr

        output[output < 0] = 0
    envi.save_image("result.hdr", output, dtype=np.uint16, interleave='bil', ext='bil',force=True)
    output_hsi = envi.open(image_hdr_file, "result.bil")

    for hsi in [image_hsi, cal_hsi, output_hsi]:
        show_rgb(hsi, None)
    print(image_hsi, cal_hsi)


if __name__ == "__main__":
    image_hdr_file = sys.argv[1]
    image_bil_file = sys.argv[2]
    cal_hdr_file = sys.argv[3]
    cal_bil_file = sys.argv[4]
    t = int(sys.argv[5])
    hsi = calibration(image_hdr_file, image_bil_file, cal_hdr_file, cal_bil_file, ["average", "demo"], t)

